
in vec4 fragTexCoord;

out vec4 fragOut0;

layout (binding = 0) uniform sampler2D composite;
layout (binding = 1) uniform sampler2D emissive;
layout (binding = 2) uniform sampler2D depth;
layout (binding = 3) uniform sampler3D volume_tex;

layout (std140) uniform genericData {
	mat4 p_inv;
	mat4 v_inv;
	vec3 camera;
	float zNear;
	float zFar;
	float stepsize;
	float globalstepalpha;
	float alphalim;
};

void main()
{
	vec4 eyeDirection = p_inv * vec4(fragTexCoord.xy * 2.0 - 1.0, -1, 1);
    eyeDirection.w = 0;
    vec3 rayDirection = normalize((v_inv * eyeDirection).xyz);
	
	vec4 color_in = texture(composite, fragTexCoord.xy);

	vec3 lCorner = vec3(-30, -30, -30);
	vec3 rCorner = vec3(30, 30, 30);
	
	vec3 t1 = (lCorner - camera) / rayDirection;
	vec3 t2 = (rCorner - camera) / rayDirection;

	vec3 tMin = min(t1, t2);
	vec3 tMax = max(t1, t2);

	float depth = 2.0 * zNear * zFar / (zFar + zNear - (2 * texture(depth, fragTexCoord.xy).x - 1) * (zFar - zNear));

	float maxtMin = max(0,max(tMin.x, max(tMin.y, tMin.z)));
	float mintMax = min(depth, min(tMax.x, min(tMax.y, tMax.z)));

	float cumOMAlpha = 1;
	vec3 cumcolor = vec3(0, 0, 0);
	float stepalpha;
	vec4 stepcolor;

	for(float step = maxtMin; step < mintMax; step += stepsize) {
		vec3 stepcolor_diffuse = texture(volume_tex, (camera + rayDirection * step) / 60.0 + 0.5);
		vec3 stepcolor_emissive = vec3(0,0,0);
		stepcolor = clamp(stepcolor_diffuse + stepcolor_emissive, 0, 1);
		stepalpha = globalstepalpha * stepcolor.a;

		cumcolor += stepalpha * cumOMAlpha * stepcolor.rgb;
		cumOMAlpha *= 1.0 - stepalpha;

		if(cumOMAlpha < alphalim)
			break;
	}

	cumcolor += cumOMAlpha * color_in.rgb;

	fragOut0 = vec4(cumcolor, 1);
}
