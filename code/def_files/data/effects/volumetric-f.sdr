
in vec4 fragTexCoord;

out vec4 fragOut0;

layout (binding = 0) uniform sampler2D composite;
layout (binding = 1) uniform sampler2D emissive;
layout (binding = 2) uniform sampler2D depth;
layout (binding = 3) uniform sampler3D volume_tex;
//layout (binding = 4) uniform sampler3D noise_volume_tex;

layout (std140) uniform genericData {
	mat4 p_inv;
	mat4 v_inv;
	vec3 camera;
	float zNear;
	vec3 globalLightDirection;
	float zFar;
	vec3 globalLightDiffuse;
	float stepsize;
	vec3 nebPos;
	float globalstepalpha;
	vec3 nebSize;
	float alphalim;
	float emissiveSpreadFactor;
	float emissiveIntensity;
	float emissiveFalloff;
	float henyeyGreensteinCoeff;
	int directionalLightSampleSteps;
	float directionalLightStepSize;
	//float noiseNear;
	//float noiseFar;
	//float noiseScale;
};

const float sqrt2_inv = inversesqrt(2);
const float sqrt4pi_inv = inversesqrt(4.0 * 3.14159);
const float beer_powder_norm = 3.0/2.0 * sqrt(3.0);

//HG assumes that the scatter vectors between which is theta both point away from the point of scatter
float henyey_greenstein(float cosTheta) {
	float radicant = 1.0 + henyeyGreensteinCoeff * henyeyGreensteinCoeff + 2.0 * henyeyGreensteinCoeff * cosTheta;
	return sqrt4pi_inv * (1.0 - henyeyGreensteinCoeff * henyeyGreensteinCoeff) / pow(radicant, 3.0 / 2.0);
}

/*
Base idea of sampling volumetrics from multiple LOD 3D-Textures with cloud models / noise as well as the shading for the diffuse
part of the volumetrics is adapted from Andrew Schneider's 2015 SIGGRAPH talk "The real-time volumetric cloudscapes of Horizon: Zero Dawn".
*/

void main()
{
	vec4 eyeDirection = p_inv * vec4(fragTexCoord.xy * 2.0 - 1.0, -1, 1);
    eyeDirection.w = 0;
    vec3 rayDirection = normalize((v_inv * eyeDirection).xyz);

	vec4 color_in = texture(composite, fragTexCoord.xy);

	vec3 lCorner = nebPos - nebSize * 0.5;
	vec3 rCorner = nebPos + nebSize * 0.5;
	
	vec3 t1 = (lCorner - camera) / rayDirection;
	vec3 t2 = (rCorner - camera) / rayDirection;

	vec3 tMin = min(t1, t2);
	vec3 tMax = max(t1, t2);

	float depth = 2.0 * zNear * zFar / (zFar + zNear - (2 * texture(depth, fragTexCoord.xy).x - 1) * (zFar - zNear));

	float maxtMin = max(0,max(tMin.x, max(tMin.y, tMin.z)));
	float mintMax = min(depth, min(tMax.x, min(tMax.y, tMax.z)));

	float cumOMAlpha = 1;
	float cumnebdist = 0;
	//float cumnoisedist = 0;
	//float noisemax = 0;
	vec3 cumcolor = vec3(0, 0, 0);

	//While not perfectly accurate, it's sufficient to assume all gradients for the 3d texture lookups are identical
	vec3 initialPos = (camera + rayDirection * maxtMin) / nebSize + 0.5;
	vec3 gradX = dFdx(initialPos);
	vec3 gradY = dFdy(initialPos);

	for(float step = maxtMin; step < mintMax; step += stepsize) {
		//Step setup
		vec3 position = camera + rayDirection * step;
		vec4 volume_sample = textureGrad(volume_tex, position / nebSize + 0.5, gradX, gradY);
		float stepcolor_alpha = volume_sample.a;

		//Noise - Technically, this should do noise, but I'm not very happy with how it turned out. The cloud needs to be "eroded" by the noise, but it's unclear as to how that can be achieved.
		//cumnoisedist += stepcolor_alpha * stepsize;
		//vec3 noise = textureGrad(noise_volume_tex, position * noiseScale, gradX, gradY).rgb;
		//noisemax = max(noisemax, (1.0 - (noise.r * noise.g * noise.b * 1.5 * (1.0 - smoothstep(noiseNear, noiseFar, cumnoisedist)))) * smoothstep(0.05, 0.15, stepcolor_alpha));
		//stepcolor_alpha *= noisemax;

		//Diffuse
		vec3 stepcolor_diffuse = volume_sample.rgb * henyey_greenstein(dot(rayDirection, globalLightDirection));
		float directionalLightStep = 4.0 / float(directionalLightSampleSteps);
		float directionalLightDepth = 0.1;
		for(int dlstep = 1; dlstep <= directionalLightSampleSteps; dlstep++){
			//TODO Sample these in a cone towards the sun, not just a line. Also add the high-distance sample for concave nebulae
			float dlstepalpha = textureGrad(volume_tex, (position - globalLightDirection * (dlstep * directionalLightStepSize)) / 60.0 + 0.5, gradX, gradY).a;
			directionalLightDepth += dlstepalpha * directionalLightStep;
		}
		stepcolor_diffuse *= beer_powder_norm * (1 - exp(-directionalLightDepth * 2.0)) * exp(-directionalLightDepth);

		//Emissive
		cumnebdist += stepcolor_alpha * stepsize;
		vec3 emissive_lod = textureLod(emissive, fragTexCoord.xy, clamp(cumnebdist * emissiveSpreadFactor, 0, float(textureQueryLevels(emissive) - 1))).rgb;
		vec3 stepcolor_emissive = emissive_lod.rgb * pow(1 - globalstepalpha, (depth - step) * emissiveFalloff) * emissiveIntensity;

		//Step finish
		vec3 stepcolor = clamp(stepcolor_diffuse + stepcolor_emissive, 0, 1);
		float stepalpha = globalstepalpha * stepcolor_alpha;
		cumcolor += stepalpha * cumOMAlpha * stepcolor;
		cumOMAlpha *= 1.0 - stepalpha;

		if(cumOMAlpha < alphalim)
			break;
	}

	cumcolor += cumOMAlpha * color_in.rgb;

	fragOut0 = vec4(cumcolor, 1);
}
