
in vec4 fragTexCoord;

out vec4 fragOut0;

layout (binding = 0) uniform sampler2D composite;
layout (binding = 1) uniform sampler2D emissive;
layout (binding = 2) uniform sampler2D depth;
layout (binding = 3) uniform sampler3D volume_tex;

layout (std140) uniform genericData {
	mat4 p_inv;
	mat4 v_inv;
	vec3 camera;
	float zNear;
	vec3 globalLightDirection;
	float zFar;
	vec3 globalLightDiffuse;
	float stepsize;
	float globalstepalpha;
	float alphalim;
	float emissiveSpreadFactor;
	float emissiveIntensity;
	float emissiveFalloff;
	float heyneyGreensteinCoeff;
	int directionalLightSampleSteps;
	float directionalLightStepSize;
};

const float sqrt2_inv = inversesqrt(2);
const float sqrt4pi_inv = inversesqrt(4.0 * 3.14159);
const float beer_powder_norm = 3.0/2.0 * sqrt(3.0);

//HG assumes that the scatter vectors between which is theta both point away from the point of scatter
float henyey_greenstein(float cosTheta) {
	float radicant = 1.0 + heyneyGreensteinCoeff * heyneyGreensteinCoeff + 2.0 * heyneyGreensteinCoeff * cosTheta;
	return sqrt4pi_inv * (1.0 - heyneyGreensteinCoeff * heyneyGreensteinCoeff) / pow(radicant, 3.0 / 2.0);
}

/*
Base idea of sampling volumetrics from multiple LOD 3D-Textures with cloud models / noise as well as the shading for the diffuse
part of the volumetrics is adapted from Andrew Schneider's 2015 SIGGRAPH talk "The real-time volumetric cloudscapes of Horizon: Zero Dawn".
*/

void main()
{
	vec4 eyeDirection = p_inv * vec4(fragTexCoord.xy * 2.0 - 1.0, -1, 1);
    eyeDirection.w = 0;
    vec3 rayDirection = normalize((v_inv * eyeDirection).xyz);

	vec4 color_in = texture(composite, fragTexCoord.xy);

	vec3 lCorner = vec3(-30, -30, -30);
	vec3 rCorner = vec3(30, 30, 30);
	
	vec3 t1 = (lCorner - camera) / rayDirection;
	vec3 t2 = (rCorner - camera) / rayDirection;

	vec3 tMin = min(t1, t2);
	vec3 tMax = max(t1, t2);

	float depth = 2.0 * zNear * zFar / (zFar + zNear - (2 * texture(depth, fragTexCoord.xy).x - 1) * (zFar - zNear));

	float maxtMin = max(0,max(tMin.x, max(tMin.y, tMin.z)));
	float mintMax = min(depth, min(tMax.x, min(tMax.y, tMax.z)));

	float cumOMAlpha = 1;
	float cumnebdist = 0;
	vec3 cumcolor = vec3(0, 0, 0);

	for(float step = maxtMin; step < mintMax; step += stepsize) {
		//Step setup
		vec3 position = camera + rayDirection * step;
		vec4 volume_sample = texture(volume_tex, position / 60.0 + 0.5);
		float stepcolor_alpha = volume_sample.a;
		cumnebdist += stepcolor_alpha * stepsize;

		//Diffuse
		vec3 stepcolor_diffuse = volume_sample.rgb * henyey_greenstein(dot(rayDirection, globalLightDirection));
		float directionalLightStep = 4.0 / float(directionalLightSampleSteps);
		float directionalLightDepth = 0.1;
		for(int dlstep = 1; dlstep <= directionalLightSampleSteps; dlstep++){
			float dlstepalpha = texture(volume_tex, (position - globalLightDirection * (dlstep * directionalLightStepSize)) / 60.0 + 0.5).a;
			directionalLightDepth += dlstepalpha * directionalLightStep;
		}
		stepcolor_diffuse *= beer_powder_norm * (1 - exp(-directionalLightDepth * 2.0)) * exp(-directionalLightDepth);

		//Emissive
		vec3 emissive_lod = textureLod(emissive, fragTexCoord.xy, clamp(cumnebdist * emissiveSpreadFactor, 0, float(textureQueryLevels(emissive) - 1))).rgb;
		vec3 stepcolor_emissive = emissive_lod.rgb * pow(1 - globalstepalpha, (depth - step) * emissiveFalloff) * emissiveIntensity;

		//Step finish
		vec3 stepcolor = clamp(stepcolor_diffuse + stepcolor_emissive, 0, 1);
		float stepalpha = globalstepalpha * stepcolor_alpha;
		cumcolor += stepalpha * cumOMAlpha * stepcolor;
		cumOMAlpha *= 1.0 - stepalpha;

		if(cumOMAlpha < alphalim)
			break;
	}

	cumcolor += cumOMAlpha * color_in.rgb;

	fragOut0 = vec4(cumcolor, 1);
}
