in vec4 fragTexCoord;
out vec4 fragOut0;
out vec4 fragOut1;
out vec4 fragOut2;
out vec4 fragOut3;
out vec4 fragOut4;
out vec4 fragOut5;
out float gl_FragDepth;

uniform sampler2DMS texColor;
uniform sampler2DMS texPos;
uniform sampler2DMS texNormal;
uniform sampler2DMS texSpecular;
uniform sampler2DMS texEmissive;
uniform sampler2DMS texDepth;

layout (std140) uniform genericData {
	int samples;
	float fov;
};

const float voxelDepth = 2.5f;
const float voxelDepthFalloff = 2.5f;

void main()
{
	vec2 texSize = textureSize(texColor);
	ivec2 texel = ivec2(texSize * fragTexCoord.xy);

	float texelWidthFactor = tan(fov / texSize.y);

	float minDist = -65536;
	for(int i = 0; i < samples; i++) {
		minDist = max(minDist, texelFetch(texPos, texel, i).z);
	}

	float weight = 0.0f;
	vec4 color = vec4(0);
	vec4 pos = vec4(0);
	vec4 normal = vec4(0);
	vec4 specular = vec4(0);
	vec4 emissive = vec4(0);
	float depth = 0;

	for(int i = 0; i < samples; i++) {
		vec4 localPos = texelFetch(texPos, texel, i);
		//Calculate local weight from distance Voxel, but if the distance is 0 (i.e. no model at all), set weight to 1 to allow stuff like background emissive
		float localWeight = max(step(-0.001, minDist), smoothstep(minDist + minDist * texelWidthFactor * (voxelDepth + voxelDepthFalloff), minDist + minDist * texelWidthFactor * voxelDepth, localPos.z));

		pos += localPos * localWeight;
		color += texelFetch(texColor, texel, i) * localWeight;
		normal += texelFetch(texNormal, texel, i) * localWeight;
		specular += texelFetch(texSpecular, texel, i) * localWeight;
		emissive += texelFetch(texEmissive, texel, i) * localWeight;
		depth += texelFetch(texDepth, texel, i).x * localWeight;
		weight += localWeight;
	}

	fragOut0 = color / weight;
	fragOut1 = pos / weight;
	fragOut2 = normalize(normal);
	fragOut3 = specular / weight;
	fragOut4 = emissive / weight;
	gl_FragDepth = depth / weight;
}
